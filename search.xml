<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[原型对象]]></title>
      <url>%2F2017%2F03%2F29%2F%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[这次主要谈一谈对原型和原型链继承的理解。 构造函数所有的函数在初始化的时候都有一个prototype属性，初始值是一个空对象。函数在作为构造器的时候，prototype属性发挥的作用才更大。 构造函数的实例初始化可以在构造器内绑定操作，也可以在构造器的原型上绑定操作。两种方式存在优先级。 1234567891011function Learn()&#123; this.study=function()&#123; console.log(&apos;good!&apos;) &#125;&#125;Learn.prototype.study=function()&#123; console.log(&apos;nice!&apos;)&#125;let storm = new Learn();storm.study() //good! 从代码可以看出，在 构造器内绑定的操作优先级高于在原型上绑定的操作。 当通过构造器创建一个实例对象，我们要引用实例对象上的一个属性时，首先查找实例对象上是否有该属性，有则返回，没有的话则通过实例对象上的constructor属性指向其构造器，再通过构造器的prototype属性指向prototype原型对象，在原型对象上查找该属性，有则返回，没有则该属性值为undefined。总结为：查询实例对象属性引用时，首先查询对象自身，如果没有，则才在原型上查找。 我们如何确定一个对象的构造器，可通过以下方法： 12345678function A()&#123; &#125;; //创建构造器Alet a = new A();console.log(typeof a === &apos;object&apos;) // true,只能确定a是一个对象console.log(a instanceof A) //true, 可以确定a的构造器是Aconsole.log(a.constructor) //A(),每个构造器实例化的对象都含有一个隐式属性constructor，其值为构造器console.log(A.prototype) // Object &#123; &#125;,构造器A的原型是一个对象console.log(A.prototype.constructor) //A()&#123; &#125;,构造器的原型对象的constructor属性指向自身构造器console.log(A.constructor) //function Function()&#123; &#125;,每个构造函数的constructor都指向Function构造器 当在进行构造器调用时，如果调用者没有引用关键字new，则会产生错误并使后续代码紊乱，可以如下修改： 123456function A(old,new)&#123; if (!(this instanceof arguments.callee))&#123; //arguments.callee得到当前执行函数的引用，在严格模式下不能使用。 return new A(old,new); &#125; // do something&#125; 这样就不怕忘了new关键字了！省点时间多看片。 原型链与继承函数原型是一个对象，可以为其添加属性和方法。要实现继承，可以通过原型链，而原型链创建的最好方式是，一个构造器的原型对象是另一个构造器的实例： 123456789101112131415161718192021//创建构造器Afunction A()&#123; this.go=function()&#123; console.log(&apos;one&apos;) &#125;&#125;A.prototype.do=function()&#123; console.log(&apos;two&apos;)&#125;//创建构造器Bfunction B()&#123; &#125;//实现继承B.prototype = new A();let b = new B();b.go(); // oneb.do(); // twoconsole.log(b instanceof B); // trueconsole.log(b instanceof A) // true 一个实例对象的创建，包含了构造器内的操作，同时也包括的了构造器原型上的操作。当另一构造器原型引用此实例时，也就引用了原构造器内的操作和其原型内的操作，也就实现了继承。同时此构造器的实例也是原构造器的实例。而这种实现的继承是是实时更新的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对apply和call的理解]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%AF%B9apply%E5%92%8Ccall%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[apply()和call()作为函数的方法，会改变函数的上下文，显式把其他对象作为函数的上下文。会改变函数内的this指向。 12345678var a = 1;function origin()&#123; console.log(this.a) //调用origin()控制台输出1，实际为window.origin()，orign的上下文是window&#125;var context=&#123; a:2 &#125;//改变origin上下文origin.call(context) //控制台输出2,origin内的this指向context，origin的上下文为context apply()和call()区别主要是参数的区别： 12f1.call(f,a,b,c);f1.apply(f,[a,b,c]); apply传入的参数是数组，call传入的参数是参数列表。传入的参数会作为以上f1函数的实参。当调用apply和call方法时，其实也相当于调用了函数。 运用此方法，实现一个forEach函数： 123456789function forEach(list,callback)&#123; if (Array.isArray(list) === true &amp;&amp; typeof callback === &apos;function&apos;)&#123; for (var n=0;n&lt;list.length;n++)&#123; callback.call(list[n],n) // 把callback内的this指向改为指向list[n],其上下文是list[n] &#125; &#125;else&#123; console.log(&apos;error&apos;) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数(一）]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%87%BD%E6%95%B0(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[函数是javascript的代码执行的模块化单元，了解函数是学习JS的基础中的基础。函数式作为JS中的第一型对象，可以视为其他任意类型的JS对象，可被任何变量进行引用。 函数声明函数的创建是要通过函数字面量进行声明，主要有四个部分组成： function关键字 可选的函数名称 圆括号()。由逗号隔开的参数标识符。可为空，但必须有括号 大括号{}组成函数体 函数的参数函数参数分为显式传入的参数和隐式参数。显式参数直接在圆括号内写入形参，待函数调用时再传入实际的参数。隐式参数主要有arguments和this。函数可以接受任意数量的参数。在JS中，没有强制声明函数有多少个参数就得传入多少个参数，可以没有形参，调用时再传入多个参数。参数的实际使用要看函数的定义。 arguments是所有参数的一个集合，有length属性。arguments.length的值是函数调用时传入的参数的个数。arguments是类数组结构，拥有数组的某些特性。能够对其进行遍历，但没有数组所具有的方法。 函数在调用时，除了显式传入的参数，还有名为this的参数也传入函数。this参数引用了函数声明时所在的上下文对象。 作用域函数的作用域是由function进行声明的，而不是代码块。作用域创建于代码块，但不终结于代码块。 1234function demo()&#123; var a = 1;&#125;console.log(a) //1 在函数的代码块之外，其声明的变量依然可用。函数的作用域要由函数所在的上下文决定。 函数的作用域分为其自身的的作用域和其所在的作用域。 12345678910111213var a1 = &apos;one&apos;;function outer()&#123; var a2 = &apos;two&apos;; console.log(a1) //one console.log(a3) //undefined function inner()&#123; var a3 = &apos;three&apos;; console.log(a2) //two console.log(a1) //undefined &#125; innner();&#125; 函数内的代码能访问其函数所在的作用域和自身的作用域，不能访问其内部函数的作用域，也不能间隔访问其祖作用域。 函数的调用函数的调用实际上有四种方式： 作为函数进行调用，比如demo()。其本质上也是方法调用，是在全局window的上下文中调用 demo() === window.demo() 作为方法进行调用,比如var a={};a.b=function(){//do something} 作为构造器进行调用，比如 function F(){}; var p = new F() 通过apply()和call()函数方法进行调用。 前面两种调用都容易理解，主要解释一下构造器调用，apply和call看下一篇博文。 12function F()&#123; //do something &#125;var f = new F() // 调用构造函数F() 构造函数同过new关键字进行调用，其会发生如下行为： 创建一个新的空对象，上面的例子就是创造了对象f。可以在此对象内添加属性和方法，this指向创建的对象实例。 新的对象实例作为this参数隐式的传递给构造函数，并成为构造函数的函数上下文。 构造函数没有显式的返回值，新创建的对象作为构造函数的返回值进行返回。 构建器函数的目的是当进行构造器调用时，会初始化创建新对象。当在构造器内添加方法和属性，调用构造器产生的新对象则会初始含有这些方法和属性，相当于构造器作为模板，以此模板不断复制新的对象，每个对象都独立，可以单独为每个对象添加新的方法和属性，互不干扰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再次出发]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%86%8D%E6%AC%A1%E5%87%BA%E5%8F%91%2F</url>
      <content type="text"><![CDATA[1. 回首过去自从2016年10月开始听说前端这个东西时，就产生了兴趣。又对当时的工作不满意，没有发展前景。自然而然，放弃当时的工作，投身到前端的大坑中。也是初生牛犊不怕虎，觉得前端也就那么回事，好好地闷头自学两三个月，还怕找不到工作。抱着这样的心态，开始了前端的学习。中间断断续续，也没有系统的好好研究，总是这里学一点，那里看一点。虽说知道是个怎么回事，但深层次的原理却一知半解。期间更是有一个月没有看书学习，让本不牢靠的基础更加不稳。如今到了现在，工作也辞了，前端工作也找不到，想着未来，心里是一片慌张和迷茫。 2.活在当下过去的总是过去，虽时常幻想着能重来，能回到大学，回到高中，该有多好，绝不会如现在这般狼狈。但生活在继续，历史长河滚滚向前，一切都需自己掌握。现在要认清自己，找到自己的路，坚持自己梦想。不管现在是如何地苟且，诗和远方一直在心中。既定了自己要奔向前端之坑，则要好好的在当下努力，多看，多问，多总结。既要掌握前端的必备技能，也要学习软件开发的基础。现有如下的方面需要掌握：- JS：掌握原理层次的东西，是前端开发的重中之重 - CSS：学习一些技巧方面的东西 - 框架：vue，react - 算法 - 数据结构 - 数据库 - 软件工程：一些软件开发的基础性理论 3.遥望未来未来实在自己的手上的。希望能在不知多远的将来，也能开发出有利于前端进步的东西。也希望自己掌握更多技能，交到更多志同道合的朋友。如果有可能，希望能够考研继续深造，在校园里更系统的学习计算机方面的知识。再次出发，就趁现在！]]></content>
    </entry>

    
  
  
</search>
