<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[脚本化文档]]></title>
      <url>%2F2017%2F04%2F20%2F%E8%84%9A%E6%9C%AC%E5%8C%96%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[脚本化CSS]]></title>
      <url>%2F2017%2F04%2F20%2F%E8%84%9A%E6%9C%AC%E5%8C%96CSS%2F</url>
      <content type="text"><![CDATA[这一篇博文主要来谈谈如何用JS操作CSS。 前言元素的样式包括标签内的style属性(内联样式)、样式表、style标签样式。内联样式的优先级最高，即使其他样式使用了！important规则也没用。 特性(Attribute)和属性(Property)当想要获取元素的特性时，我们可以通过getAttribute()和元素对象的属性引用两种方式来获取： 1234elm.getAttribute(&apos;id&apos;); //通过方法获取elm.setAttribute(&apos;id&apos;,&apos;demo&apos;) //通过方法设置var sheet = elm.id; //通过元素对象获取elm.id = &apos;demo&apos; ; //通过元素对象设置 如果我们通过以上方式改变元素的属性时，其中一种的改变设置也会影响另一种对元素属性的获取。换句话说：设置特性的值，也会改变属性的值。 当获取属性或特性时，有一些注意事项： 跨浏览器命名。在不同浏览器间，获取特性的名称可能不同，比如大多数浏览器可以通过class获取class值，但在IE中要通过className来获取class值。 命名限制。通过特性方法来对元素特性命名比较自由，而通过元素对象点标识符来设置属性时，则要符合标识符命名规则。 XML和HTML之间的差异。 自定义特性的行为。自定义的特性要通过特性方法来访问。而通过属性的方式能访问原生属性。 性能。属性的访问速度比特性方法的访问速度要快。 脚本化内联样式1234elm.style.color = &apos;#121212&apos;;elm.style.fontSize = 18 + &apos;px&apos;;elm.style.fontFamily = &apos;sans-serif&apos;;elm.style.cssFloat = &apos;left&apos;; 脚本化CSS一般都直接访问标签内的style对象，而对象内的属性要用小驼峰式命名，而属性值都为字符串。有一些属性在JS是保留字，其属性名要有特殊的命名，比如float属性要写为cssFloat。 同时，有些属性值必须带有单位，可以是数字加上字符串单位。 有时要访问元素的高度和宽度时，可以使用offsetWidth和offsetHeight。但这两个属性同时包括元素的边框宽度和内边距的宽度。 计算样式 元素的计算样式是一组属性值，是元素实际显示时所使用的样式。计算样式只读，用CSSStyleDeclaration对象表示。 我们可以用window.getComputedStyle(elm,’’)方法得到元素的计算样式。返回的是CSSStyleDeclaration对象。此方法不计算复合属性，比如border、margin。计算样式的值时绝对值，百分比、名称属性值或点之类的相对单位都会转为绝对值。 123var e = document.getElementById(&apos;demo&apos;);var Estyle = window.getComputedStyle(e,&quot;&quot;); //返回CSSStyleDeclaration对象var color = Estyle.color; // 通过Estyle对象获取颜色值 脚本化CSS类 我们可以通过设置标签的class属性值，来改变元素的一组样式。 123456789101112131415.demo1&#123; font-size:20px; color: blue;&#125;.demo2&#123;background-color:red;margin-top:20px;&#125; var e = document.getElementById(&apos;app&apos;); e.className = &apos;demo&apos;1; e.setAttribute(&apos;class&apos;,&apos;demo1&apos;) //另一种方式实现 //如果有多个类，设置className会覆盖前面的类，可使用classList属性,classList属性 //有5个方法：add(), remove(), toggle(), contains(), item() e.classList.add(&apos;demo2&apos;) 脚本化样式表如果需要用户操作页面的样式，则需要动态的操作样式表。我们可以通过document.styleSheets类数组对象来操作，其中含有CSSStyleSheet对象元素，表示与文档关联在一起的样式表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定时器]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[定时器是在设置一定时间后执行回调函数的功能。定时器函数作为全局window的方法,是全局函数。 定时器和线程JavaScript是单线程执行的，这意味着在同一时间JS只能执行一个任务，而其他的任务需要排队，等到线程把当前任务执行完毕且空闲时，再从任务队列中选取任务执行。而任务队列的任务优先级根据不同的浏览器会有不同的算法。浏览器负责任务排序，指定某个时间点执行某个任务的优先级。 任务队列的添加时按照不同的代码被触发时的时间先后逐渐的添加到队列中。而定时器的时间设置则是指在指定时间后把要执行的的代码添加的任务队列中，而不是指定时间后立即执行代码。可能当定时器任务添加到队列中时，前面还有其他任务，只有当前面的任务执行完毕，线程空闲，才会执行定时器任务。 定时器函数定时器有四个方法，皆为window的方法。 setTimeout(callback,time) clearTimeout(ID) ID为setTimeout返回的标识 setInterval(callback,time) clearInterval(ID) ID 为setInterval返回的标识 setTimeout函数在指定时间后把回调函数添加到任务队列中，且只添加一次。如果setTimeout函数还未被线程执行，可以使用clearTimeout函数取消任务队列中setTimeout函数。 setInterval函数是在指定间隔时间后重复添加回调函数到任务队列中，如果任务队列有相同的setInterval函数实例，则不会添加相同实例。clearInterval函数可以取消任务队列中setInterval函数。tip：指定延迟时间会包含执行时间 setInterval函数的间隔等待时间可能会包含其回调函数的执行时间，如果执行时间比间隔时间大，在上一个setInterval函数执行期间，下一个setInterval函数会添加到任务队列中，则会setInterval函数执行完一个，会立即执行下一个。则会觉得其间隔会被跳过，没有达到预期目的。为了避免这种情况，可以使用链式setTimeoout(): 1234setTimeout(function()&#123; //do something setTimeout(arguments.callee,time) //arguments.callee指向为当前执行函数的引用&#125;,time) 定时器的其他用处处理需要长时间运行的程序如果一段代码运行时间过长，浏览器会无法及时响应，会阻塞其他操作，导致用户体验变差。我们可以通过定时器来解决，可以把代码分解成各个部分，分解成不会让浏览器无法响应的碎片。 example: 123456789101112131415161718192021222324var rowCount = 200000;var divideInto = 4;var chunkSize = rowCount/divideInto;var iteration = 0;var table = doucment.getElementsByTagName(&apos;tbody&apos;)[0];setTimeout(function generateRows()&#123; //分块操作 var base = (chunkSize) * iteration; for (var i = 0; i&lt;chunkSize;i++)&#123; var tr = document.createElement(&apos;tr&apos;); for (var t =0;t &lt; 6;t++)&#123; var td = document.createElement(&apos;td&apos;); td.appendChild(document.createTextNode((i+base)+&apos;,&apos;+t+&apos;,&apos;+iteration)); tr.appendChild(td); &#125; table.appendChild(tr); &#125; // 继续执行下一块操作 iteration++; if (iteration &lt; divideInto)&#123; setTimeout(generateRows,0); &#125;&#125;,0) 中央定时器控制如果使用的定时器过多，会导致浏览器增加垃圾回收任务，可能会在不同浏览器中造成卡顿。而使用中央定时器控制技术可减少这种状况。现在的动画引擎很多都使用这种技术。 中央定时器控制的特点： 每个页面在同一时间只需要运行一个定时器 可以暂停或回复定时器 容易删除回调函数 ezample:管理多个函数，每个函数处理不同事物 123456789101112131415161718192021222324252627282930313233//定时器控制对象var timers = &#123; //记录状态 timeID:0, timers:[], //添加处理函数 add: function (fn)&#123; this.timers.push(fn); &#125; //开启定时器的函数 start: function ()&#123; if (this.timeID) return; //闭包 (function runNext()&#123; if (timers.timers.lenfth &gt; 0 )&#123; for (var i =0;i&lt;timers.timers.length;i++)&#123; //处理函数返回false，则删除 if (timers.timers[i]() === false)&#123; timers.timers.splice(i,1); i--; &#125; &#125; 遍历完后，再一次执行runNext timers.timerID = setTimeout(runNext,0); &#125; &#125;)(); &#125;， //停止定时器函数 stop: function ()&#123; clearTimeout(this.timeID); this.timeID = 0; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类和原型]]></title>
      <url>%2F2017%2F03%2F29%2F%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[这次主要谈一谈对原型继承和类的理解。 构造函数所有的函数在初始化的时候都有一个prototype属性，初始值是一个空对象。函数在作为构造器的时候，prototype属性发挥的作用才更大。 构造函数的实例初始化可以在构造器内绑定操作，也可以在构造器的原型上绑定操作。两种方式存在优先级。 1234567891011function Learn()&#123; this.study=function()&#123; console.log(&apos;good!&apos;) &#125;&#125;Learn.prototype.study=function()&#123; console.log(&apos;nice!&apos;)&#125;let storm = new Learn();storm.study() //good! 从代码可以看出，在 构造器内绑定的操作优先级高于在原型上绑定的操作。 当通过构造器创建一个实例对象，我们要引用实例对象上的一个属性时，首先查找实例对象上是否有该属性，有则返回，没有的话则通过实例对象上的constructor属性指向其构造器，再通过构造器的prototype属性指向prototype原型对象，在原型对象上查找该属性，有则返回，没有则该属性值为undefined。总结为：查询实例对象属性引用时，首先查询对象自身，如果没有，则才在原型上查找。 我们如何确定一个对象的构造器，可通过以下方法： 12345678function A()&#123; &#125;; //创建构造器Alet a = new A();console.log(typeof a === &apos;object&apos;) // true,只能确定a是一个对象console.log(a instanceof A) //true, 可以确定a的构造器是Aconsole.log(a.constructor) //A(),每个构造器实例化的对象都含有一个隐式属性constructor，其值为构造器console.log(A.prototype) // Object &#123; &#125;,构造器A的原型是一个对象console.log(A.prototype.constructor) //A()&#123; &#125;,构造器的原型对象的constructor属性指向自身构造器console.log(A.constructor) //function Function()&#123; &#125;,每个构造函数的constructor都指向Function构造器 当在进行构造器调用时，如果调用者没有引用关键字new，则会产生错误并使后续代码紊乱，可以如下修改： 123456function A(old,new)&#123; if (!(this instanceof arguments.callee))&#123; //arguments.callee得到当前执行函数的引用，在严格模式下不能使用。 return new A(old,new); &#125; // do something&#125; 这样就不怕忘了new关键字了！省点时间多看片。 原型链与继承函数原型是一个对象，可以为其添加属性和方法。要实现继承，可以通过原型链，而原型链创建的最好方式是，一个构造器的原型对象是另一个构造器的实例： 123456789101112131415161718192021//创建构造器Afunction A()&#123; this.go=function()&#123; console.log(&apos;one&apos;) &#125;&#125;A.prototype.do=function()&#123; console.log(&apos;two&apos;)&#125;//创建构造器Bfunction B()&#123; &#125;//实现继承B.prototype = new A();let b = new B();b.go(); // oneb.do(); // twoconsole.log(b instanceof B); // trueconsole.log(b instanceof A) // true 一个实例对象的创建，包含了构造器内的操作，同时也包括的了构造器原型上的操作。当另一构造器原型引用此实例时，也就引用了原构造器内的操作和其原型内的操作，也就实现了继承。同时此构造器的实例也是原构造器的实例。而这种实现的继承是是实时更新的。 类和原型通过构造函数的原型对象，可以实现继承。从某种意义上来说，定义构造函数就是定义类。类的所有实例对象都是从同一个原型对象上继承属性，所以原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的实例。 而实例对象的构造函数不能作为类的唯一标识，因为构造函数也可能是继承自其它的构造函数。但构造函数可以作为类的公共标识，基本上遇到构造函数，就可以认为是一个类。 instanceof运算符的检测并不会检测到一个实例对象是否由一个构造函数初始化而来，而是检测是否继承自原型对象(是否存在继承关系)。 isPrototypeOf运算符检测的是一个实例对象是否继承自该原型对象，其用法如下： 123456789function A() &#123; &#125;function B() &#123; &#125;function C() &#123; &#125;B.prototype = new A();C.prototype = new B();let c = new C();console.log(A.prototype.isPrototypeOf(c)) //true 在原型链中，上游的实例对象不能来确认下游的原型对象是其继承的。 JS中的类牵扯到三种对象： 构造函数对象：定义了类的名字，在其中添加的属性都是类字段或类方法。 原型对象：所有类的实例都继承自原型对象。 实例对象：每个实例对象都是独立对象。在实例对象内添加的方法不会被其他实例共享。添加的属性是实例字段或实例方法。 在JS定义一个类可以分成三步算法： 定义一个构造函数，在函数中定义实例对象的属性的初始化操作。 在构造函数的原型对象中定义实例的方法。 定义构造函数的类方法和类属性。 子类类B继承类A，B为子类(subclass)，A为父类(superclass)。类B定义自己的实例方法，且重载了类A中的同名方法，又调用了类A中的重载方法，这种做法则为方法链。类B调用了类A，则为构造函数链。 在javascript中，创建子类的关键在于采用合适的方法对原型对象进行初始化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对apply和call的理解]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%AF%B9apply%E5%92%8Ccall%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[apply()和call()作为函数的方法，会改变函数的上下文，显式把其他对象作为函数的上下文。会改变函数内的this指向。 12345678var a = 1;function origin()&#123; console.log(this.a) //调用origin()控制台输出1，实际为window.origin()，orign的上下文是window&#125;var context=&#123; a:2 &#125;//改变origin上下文origin.call(context) //控制台输出2,origin内的this指向context，origin的上下文为context apply()和call()区别主要是参数的区别： 12f1.call(f,a,b,c);f1.apply(f,[a,b,c]); apply传入的参数是数组，call传入的参数是参数列表。传入的参数会作为以上f1函数的实参。当调用apply和call方法时，其实也相当于调用了函数。 运用此方法，实现一个forEach函数： 123456789function forEach(list,callback)&#123; if (Array.isArray(list) === true &amp;&amp; typeof callback === &apos;function&apos;)&#123; for (var n=0;n&lt;list.length;n++)&#123; callback.call(list[n],n) // 把callback内的this指向改为指向list[n],其上下文是list[n] &#125; &#125;else&#123; console.log(&apos;error&apos;) &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数(一）]]></title>
      <url>%2F2017%2F03%2F24%2F%E5%87%BD%E6%95%B0(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[函数是javascript的代码执行的模块化单元，了解函数是学习JS的基础中的基础。函数式作为JS中的第一型对象，可以视为其他任意类型的JS对象，可被任何变量进行引用。 函数声明函数的创建是要通过函数字面量进行声明，主要有四个部分组成： function关键字 可选的函数名称 圆括号()。由逗号隔开的参数标识符。可为空，但必须有括号 大括号{}组成函数体 函数的参数函数参数分为显式传入的参数和隐式参数。显式参数直接在圆括号内写入形参，待函数调用时再传入实际的参数。隐式参数主要有arguments和this。函数可以接受任意数量的参数。在JS中，没有强制声明函数有多少个参数就得传入多少个参数，可以没有形参，调用时再传入多个参数。参数的实际使用要看函数的定义。 arguments是所有参数的一个集合，有length属性。arguments.length的值是函数调用时传入的参数的个数。arguments是类数组结构，拥有数组的某些特性。能够对其进行遍历，但没有数组所具有的方法。 函数在调用时，除了显式传入的参数，还有名为this的参数也传入函数。this参数引用了函数声明时所在的上下文对象。 作用域函数的作用域是由function进行声明的，而不是代码块。作用域创建于代码块，但不终结于代码块。 1234function demo()&#123; var a = 1;&#125;console.log(a) //1 在函数的代码块之外，其声明的变量依然可用。函数的作用域要由函数所在的上下文决定。 函数的作用域分为其自身的的作用域和其所在的作用域。 12345678910111213var a1 = &apos;one&apos;;function outer()&#123; var a2 = &apos;two&apos;; console.log(a1) //one console.log(a3) //undefined function inner()&#123; var a3 = &apos;three&apos;; console.log(a2) //two console.log(a1) //undefined &#125; innner();&#125; 函数内的代码能访问其函数所在的作用域和自身的作用域，不能访问其内部函数的作用域，也不能间隔访问其祖作用域。 函数的调用函数的调用实际上有四种方式： 作为函数进行调用，比如demo()。其本质上也是方法调用，是在全局window的上下文中调用 demo() === window.demo() 作为方法进行调用,比如var a={};a.b=function(){//do something} 作为构造器进行调用，比如 function F(){}; var p = new F() 通过apply()和call()函数方法进行调用。 前面两种调用都容易理解，主要解释一下构造器调用，apply和call看下一篇博文。 12function F()&#123; //do something &#125;var f = new F() // 调用构造函数F() 构造函数同过new关键字进行调用，其会发生如下行为： 创建一个新的空对象，上面的例子就是创造了对象 f 。可以在此对象内添加属性和方法，this指向创建的对象实例。 新的对象实例作为this参数隐式的传递给构造函数，并成为构造函数的函数上下文。 构造函数没有显式的返回值，构造函数会作为这个对象的方法来调用一次，新创建的对象作为构造函数的返回值进行返回。 构建器函数的目的是当进行构造器调用时，会初始化创建新对象。当在构造器内添加方法和属性，调用构造器产生的新对象则会初始含有这些方法和属性，相当于构造器作为模板，以此模板不断复制新的对象，每个对象都独立，可以单独为每个对象添加新的方法和属性，互不干扰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再次出发]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%86%8D%E6%AC%A1%E5%87%BA%E5%8F%91%2F</url>
      <content type="text"><![CDATA[1. 回首过去自从2016年10月开始听说前端这个东西时，就产生了兴趣。又对当时的工作不满意，没有发展前景。自然而然，放弃当时的工作，投身到前端的大坑中。也是初生牛犊不怕虎，觉得前端也就那么回事，好好地闷头自学两三个月，还怕找不到工作。抱着这样的心态，开始了前端的学习。中间断断续续，也没有系统的好好研究，总是这里学一点，那里看一点。虽说知道是个怎么回事，但深层次的原理却一知半解。期间更是有一个月没有看书学习，让本不牢靠的基础更加不稳。如今到了现在，工作也辞了，前端工作也找不到，想着未来，心里是一片慌张和迷茫。 2.活在当下过去的总是过去，虽时常幻想着能重来，能回到大学，回到高中，该有多好，绝不会如现在这般狼狈。但生活在继续，历史长河滚滚向前，一切都需自己掌握。现在要认清自己，找到自己的路，坚持自己梦想。不管现在是如何地苟且，诗和远方一直在心中。既定了自己要奔向前端之坑，则要好好的在当下努力，多看，多问，多总结。既要掌握前端的必备技能，也要学习软件开发的基础。现有如下的方面需要掌握：- JS：掌握原理层次的东西，是前端开发的重中之重 - CSS：学习一些技巧方面的东西 - 框架：vue，react - 算法 - 数据结构 - 数据库 - 软件工程：一些软件开发的基础性理论 3.遥望未来未来实在自己的手上的。希望能在不知多远的将来，也能开发出有利于前端进步的东西。也希望自己掌握更多技能，交到更多志同道合的朋友。如果有可能，希望能够考研继续深造，在校园里更系统的学习计算机方面的知识。再次出发，就趁现在！]]></content>
    </entry>

    
  
  
</search>
